<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Maze Solver</title>
    <style>
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            background: linear-gradient(45deg, #1e3c72, #2a5298);
            margin: 0;
        }
        canvas {
            border: 4px solid white;
            box-shadow: 0px 0px 20px rgba(255, 255, 255, 0.5);
            display: block;
            background-color: #111;
        }
    </style>
</head>
<body>
    <canvas id="mazeCanvas"></canvas>
    <script>
        const size = 21;
        const cellSize = 20;
        const canvas = document.getElementById("mazeCanvas");
        const ctx = canvas.getContext("2d");
        canvas.width = size * cellSize;
        canvas.height = size * cellSize;
        
        function generateMaze(size) {
            let maze = Array.from({ length: size }, () => Array(size).fill(1));
            let stack = [[1, 1]];
            maze[1][1] = 0;
            let directions = [[0, 2], [2, 0], [-2, 0], [0, -2]];
            
            while (stack.length > 0) {
                let [x, y] = stack[stack.length - 1];
                let shuffledDirs = directions.sort(() => Math.random() - 0.5);
                let moved = false;
                
                for (let [dx, dy] of shuffledDirs) {
                    let nx = x + dx, ny = y + dy;
                    if (nx > 0 && nx < size - 1 && ny > 0 && ny < size - 1 && maze[nx][ny] === 1) {
                        maze[nx][ny] = 0;
                        maze[x + dx / 2][y + dy / 2] = 0;
                        stack.push([nx, ny]);
                        moved = true;
                        break;
                    }
                }
                if (!moved) stack.pop();
            }
            return maze;
        }
        
        function drawMaze(maze) {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            for (let i = 0; i < size; i++) {
                for (let j = 0; j < size; j++) {
                    ctx.fillStyle = maze[i][j] === 1 ? "#2c3e50" : "#ecf0f1";
                    ctx.fillRect(j * cellSize, i * cellSize, cellSize, cellSize);
                }
            }
            
            // Отмечаем старт и финиш контрастными цветами
            ctx.fillStyle = "#27ae60"; // Яркий зелёный для входа
            ctx.beginPath();
            ctx.arc(1 * cellSize + cellSize / 2, 1 * cellSize + cellSize / 2, cellSize / 3, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.fillStyle = "#e74c3c"; // Яркий красный для выхода
            ctx.beginPath();
            ctx.arc((size - 2) * cellSize + cellSize / 2, (size - 2) * cellSize + cellSize / 2, cellSize / 3, 0, Math.PI * 2);
            ctx.fill();
        }
        
        function solveMaze(maze) {
            let path = [];
            let visited = Array.from({ length: size }, () => Array(size).fill(false));
            
            function dfs(x, y) {
                if (x === size - 2 && y === size - 2) return true;
                visited[x][y] = true;
                path.push([x, y]);
                let directions = [[1, 0], [0, 1], [-1, 0], [0, -1]];
                for (let [dx, dy] of directions) {
                    let nx = x + dx, ny = y + dy;
                    if (nx > 0 && nx < size && ny > 0 && ny < size && maze[nx][ny] === 0 && !visited[nx][ny]) {
                        if (dfs(nx, ny)) return true;
                    }
                }
                path.pop();
                return false;
            }
            dfs(1, 1);
            return path;
        }
        
        function animatePath(path, callback) {
            let i = 0;
            function step() {
                if (i < path.length) {
                    let [x, y] = path[i];
                    if ((x !== 1 || y !== 1) && (x !== size - 2 || y !== size - 2)) {
                        ctx.fillStyle = `rgba(0, 176, 255, ${0.7 + 0.3 * (i / path.length)})`;
                        ctx.fillRect(y * cellSize, x * cellSize, cellSize, cellSize);
                    }
                    i++;
                    setTimeout(step, 40);
                } else {
                    setTimeout(callback, 500);
                }
            }
            step();
        }
        
        function generateAndSolve() {
            let maze = generateMaze(size);
            drawMaze(maze);
            let path = solveMaze(maze);
            animatePath(path, generateAndSolve);
        }
        
        generateAndSolve();
    </script>
</body>
</html>